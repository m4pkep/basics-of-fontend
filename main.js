'use strict';
// современный режим появился в 2009 с экмаскрипт ес5
// который пофиксил все застрявшие в языке ошибки

let param1 = "Hello";
console.log(param1);

const param2 = 200; 

var param3;

// у var функциональная область видимости и доступна до объявления
// а у let только в ее блоке где она объявлена
// вар одну и ту же можно два раза объявить и не будет ошибок а
// просто будет перезаписана переменная что приведет к ошибкам
// Hoisting. тк вар можно использовать до объявления это может
// привести к логическим ошибкам в коде => let просто безопаснее

let name1 = 'mark';
console.log('hello', `${name1}`);

// null это пустота/ничего
// undefined это значение не присвоено, после объявления
// переменной но до инициализации она будет undefined

console.log(typeof Math);

// alert
// С этой функцией мы уже знакомы.
// Она показывает сообщение и ждёт, пока пользователь нажмёт кнопку «ОК».


// prompt
// Функция prompt принимает два аргумента:
//              result = prompt(title, [default]);
// Этот код отобразит модальное окно с текстом,
// полем для ввода текста и кнопками OK/Отмена.

// confirm
// Синтаксис:
//              result = confirm(question);
// Функция confirm отображает модальное окно с текстом вопроса question
// и двумя кнопками: OK и Отмена.
// Результат – true, если нажата кнопка OK.
// В других случаях – false.

// = присваивание
// == сравнение с приведением к одному типу
// === строгое сравнение без приведения к одному типу

// Оператор представлен знаком вопроса ?. Его также называют «тернарный»,
// так как этот оператор, единственный в своём роде, имеет три аргумента.

result = a || b;
//операттор логическое или
// если больше двух операндов то возвращает первй правдивый а если все
// ложные то последний из них

result = value1 && value2;
// Другими словами,
// И возвращает первое ложное значение. Или последнее, если ничего не найдено.

a &&= b;
// логическое присваивание
// Единственное отличие заключается в том
// что &&= присвоит a значение b только в том случае, если a истинно.

// оператор нулевого слияния
// Иначе говоря, оператор ?? возвращает первый аргумент,
// если он не null/undefined, иначе второй.

result1 = (a !== null && a !== undefined) ? a : b;
result2 = a ?? b;

let firstName = null;
let lastName = null;
let nickName = "Суперкодер";

// показывает первое значение, которое определено:
alert(firstName ?? lastName ?? nickName ?? "Аноним"); // Суперкодер

// Важное различие между ними заключается в том, что:
// || возвращает первое истинное значение
// ?? возвращает первое определённое значение

// оператор нулевого присваивания ??=
// Оператор ??= присвоит x значение y только в том случае,
// если x не определено (null/undefined).

x ??= y;

let num1 = 10,
    num2 = 20,
    result;

result ??= num1 ?? num2;

let i = 3;
while (i) alert(i--);

do {
    alert(i);
    i--;
} while (i > 0);
// в do while сначала в любом случае выполняется цикл 1 раз

for (let i1 = 0; i < 10; i++) {
    alert(i);
}

// из цикла можно выйти в любой момент с помощью break
// брейк передает управление на строку после тела цикла
let sum = 0;

while (true) {
  let value = +prompt("Введите число", '');
  if (!value) break; // (*)
  sum += value;
}

alert( 'Сумма: ' + sum );

// continue это лайт версия break тк просто скипает итерацию
// и переходит к следующей если условие все еще true
for (let i = 0; i < 10; i++) {
  // если true, пропустить оставшуюся часть тела цикла
  if (i % 2 == 0) continue;
  alert(i); // 1, затем 3, 5, 7, 9
}
// нельзя исп break || continue после тернарного ?

outer:
for (let i = 0; i < 3; i++) { 
    for (let j = 0; j < 3; j++) {
    let input = prompt(`Значение на координатах (${i},${j})`, '');
    // если пустая строка или Отмена, то выйти из обоих циклов
    if (!input) break outer; // (*)
    // сделать что-нибудь со значениями...
  }
}
// таким образом аутер это метка докуда разрывать цикл брейку

function showMessage() {
    alert('vsem ky');
}

// Параметр – это переменная, указанная в круглых скобках в объявлении функции.
// Аргумент – это значение, которое передаётся функции при её вызове.

// функциональное выражение
let hi = function sayHi() {
    alert('zdarova');
}

//В JavaScript функция – это значение, поэтому мы можем обращаться с ней как со значением.
// Приведённый выше код показывает её строковое представление, которое является её исходным кодом.

//Ключевая идея в том, что мы передаём функцию и ожидаем, что она вызовется обратно
// (от англ. «call back» – обратный вызов) когда-нибудь позже, если это будет необходимо.
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Вы согласны?",
  function() { alert("Вы согласились."); },
  function() { alert("Вы отменили выполнение."); }
);

// Function Declaration может быть вызвана раньше, чем она объявлена.
// Другими словами, когда движок JavaScript готовится выполнять скрипт или блок кода,
// прежде всего он ищет в нём Function Declaration и создаёт все такие функции.
// Можно считать этот процесс «стадией инициализации».

//В строгом режиме, когда Function Declaration находится в блоке {...},
// функция доступна везде внутри блока. Но не снаружи него.

// СТРЕЛОЧНЫЕ ФУНКЦИИ
let func = (arg1, arg2, ...argN) => expression;

describe("pow", function() {

  it("возводит в степень n", function() {
    assert.equal(pow(2, 3), 8);
  });
});

// объектыОбъект может быть создан с помощью фигурных скобок {…}
// с необязательным списком свойств. Свойство – это пара «ключ: значение»,
// где ключ – это строка
// (также называемая «именем свойства»), а значение может быть чем угодно.

// 2 варианта создания объекта
let user1 = new Object(); // конструктор объекта
let user2 = {}; // литерал объекта


// объект с 2 свойствами и их значениями
let user3 = {
  name: 'John',
  age: 30,
  "likes birds": true,
};

alert(user3.name);
user3.isAdmin = true;
delete user3.age;

//объект объявленный через const может быть изменен
const user4 = {
  name: 'John'
};
user4.name = "Pete";

let user5 = {};
user5["like me"] = true;
delete user5["like me"];

